# Q4 å¯è§†åŒ–è§„åˆ’æ–‡æ¡£ï¼šæ–°æŠ•ç¥¨æœºåˆ¶è®¾è®¡ä¸è¯„ä¼°

**ç›®æ ‡**: é€šè¿‡å¯è§†åŒ–å±•ç¤ºQ4çš„æ ¸å¿ƒè´¡çŒ®â€”â€”è®¾è®¡å’Œè¯„ä¼°æ–°çš„æŠ•ç¥¨æœºåˆ¶ï¼Œå±•ç¤ºä¸åŒæœºåˆ¶åœ¨å…¬å¹³æ€§ã€å¨±ä¹æ€§å’Œç¨³å¥æ€§ä¹‹é—´çš„æƒè¡¡

## ğŸ“Š **æ ¸å¿ƒå¯è§†åŒ–ç›®æ ‡**

### 1. **æœºåˆ¶æƒè¡¡åˆ†æ**: å±•ç¤ºä¸åŒæœºåˆ¶åœ¨å¤šä¸ªç›®æ ‡ä¹‹é—´çš„Paretoå‰æ²¿
### 2. **ç¨³å¥æ€§éªŒè¯**: é€šè¿‡å‹åŠ›æµ‹è¯•å±•ç¤ºæœºåˆ¶åœ¨æç«¯æƒ…å†µä¸‹çš„è¡¨ç°
### 3. **æ”¿ç­–å»ºè®®æ”¯æ’‘**: ä¸ºåˆ¶ä½œæ–¹æä¾›ç›´è§‚çš„æœºåˆ¶é€‰æ‹©ä¾æ®
### 4. **åˆ›æ–°æ–¹æ³•å±•ç¤º**: åˆ©ç”¨ç‚«æŠ€å±•ç¤ºå¤šç›®æ ‡ä¼˜åŒ–å’Œæœºå™¨å­¦ä¹ åœ¨ç³»ç»Ÿè®¾è®¡ä¸­çš„åº”ç”¨

---

## âœ… ä¸»çº¿å£å¾„çº¦æŸï¼ˆå†™è¿›è®ºæ–‡æ­£æ–‡å¿…é¡»éµå®ˆï¼‰

- **ä¸»çº¿å›¾è¡¨**åªå…è®¸ä½¿ç”¨ï¼š
  - `data/processed/*.csv`
  - `outputs/tables/*.csv`
  - `outputs/predictions/*.csv`
- `outputs/tables/showcase/*` ä»…ç”¨äº**é™„å½•å¯¹ç…§/ç‚«æŠ€**ã€‚

## ğŸ¯ **ä¸»çº¿å›¾è¡¨æ¸…å•**

### å›¾4-1: æœºåˆ¶æƒè¡¡æ•£ç‚¹å›¾ (Mechanism Trade-off Scatter Plot)
**æ–‡ä»¶å**: `q4_mechanism_tradeoff_scatter.{tiff,eps}`

**ç›®çš„**: æ ¸å¿ƒå›¾è¡¨ï¼Œå±•ç¤ºä¸åŒæœºåˆ¶åœ¨æŠ€æœ¯ä¿æŠ¤vsç²‰ä¸è¡¨è¾¾ä¹‹é—´çš„æƒè¡¡å…³ç³»

**æ•°æ®æº**: 
- `outputs/tables/mcm2026c_q4_new_system_metrics.csv`
- å­—æ®µ: `mechanism, tpi_season_avg, fan_vs_uniform_contrast, outlier_mult`

**å›¾è¡¨è®¾è®¡**:
```python
fig, axes = plt.subplots(1, 3, figsize=(20, 7))

outlier_levels = [2.0, 5.0, 10.0]
colors = {
    'percent': '#1f77b4',
    'rank': '#ff7f0e',
    'percent_judge_save': '#2ca02c',
    'percent_sqrt': '#d62728',
    'percent_log': '#8c564b',
    'percent_cap': '#e377c2',
    'dynamic_weight': '#7f7f7f',
}

for i, outlier_mult in enumerate(outlier_levels):
    ax = axes[i]
    data_subset = data[data['outlier_mult'] == outlier_mult]
    
    # æŒ‰æœºåˆ¶åˆ†ç»„å¹¶è®¡ç®—å¹³å‡å€¼
    mechanism_avg = data_subset.groupby('mechanism').agg({
        'tpi_season_avg': 'mean',
        'fan_vs_uniform_contrast': 'mean',
        'robust_fail_rate': 'mean'
    }).reset_index()
    
    # æ•£ç‚¹å›¾ï¼Œç‚¹çš„å¤§å°è¡¨ç¤ºç¨³å¥æ€§
    for _, row in mechanism_avg.iterrows():
        mech = row['mechanism']
        size = (1 - row['robust_fail_rate']) * 300 + 50  # ç¨³å¥æ€§è¶Šé«˜ï¼Œç‚¹è¶Šå¤§
        ax.scatter(row['fan_vs_uniform_contrast'], row['tpi_season_avg'], 
                  s=size, c=colors[mech], alpha=0.7, label=mech)
        
        # æ·»åŠ æœºåˆ¶æ ‡ç­¾
        ax.annotate(mech.replace('_', '\n'), 
                   (row['fan_vs_uniform_contrast'], row['tpi_season_avg']),
                   xytext=(5, 5), textcoords='offset points', fontsize=10)
    
    ax.set_xlabel('ç²‰ä¸è¡¨è¾¾å¼ºåº¦ (Fan vs Uniform Contrast)')
    ax.set_ylabel('æŠ€æœ¯ä¿æŠ¤æŒ‡æ•° (TPI)')
    ax.set_title(f'å‹åŠ›æµ‹è¯• {outlier_mult}x\nç‚¹å¤§å°=ç¨³å¥æ€§')
    ax.grid(True, alpha=0.3)
    ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')

# æ·»åŠ ç†æƒ³åŒºåŸŸæ ‡æ³¨
for ax in axes:
    # é«˜æŠ€æœ¯ä¿æŠ¤ + é«˜ç²‰ä¸è¡¨è¾¾çš„ç†æƒ³åŒºåŸŸ
    ideal_rect = plt.Rectangle((0.6, 0.7), 0.3, 0.2, 
                              fill=False, edgecolor='gold', linewidth=2, linestyle='--')
    ax.add_patch(ideal_rect)
    ax.text(0.75, 0.8, 'ç†æƒ³åŒºåŸŸ', ha='center', va='center', 
           bbox=dict(boxstyle='round', facecolor='gold', alpha=0.3))

plt.tight_layout()
```

**å…³é”®è§£è¯»ç‚¹**:
- ä¸å­˜åœ¨"é“¶å¼¹"æœºåˆ¶ï¼Œéƒ½æœ‰æƒè¡¡
- `percent_judge_save`å¯èƒ½åœ¨ç†æƒ³åŒºåŸŸå†…
- å‹åŠ›æµ‹è¯•ä¸‹æœºåˆ¶æ€§èƒ½çš„å˜åŒ–è¶‹åŠ¿
- ç¨³å¥æ€§ä¸æ€§èƒ½çš„å…³ç³»

---

### å›¾4-2: ç¨³å¥æ€§æ›²çº¿å›¾ (Robustness Curves)
**æ–‡ä»¶å**: `q4_robustness_curves.{tiff,eps}`

**ç›®çš„**: å±•ç¤ºä¸åŒæœºåˆ¶åœ¨å‹åŠ›æµ‹è¯•ä¸‹çš„ç¨³å¥æ€§è¡¨ç°

**æ•°æ®æº**:
- åŒä¸Šï¼Œé‡ç‚¹åˆ†æ`robust_fail_rate`éš`outlier_mult`çš„å˜åŒ–

**å›¾è¡¨è®¾è®¡**:
```python
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))

# å·¦å›¾: ç¨³å¥æ€§å¤±è´¥ç‡æ›²çº¿
mechanisms = data['mechanism'].unique()
outlier_values = sorted(data['outlier_mult'].unique())

for mech in mechanisms:
    mech_data = data[data['mechanism'] == mech]
    fail_rates = []
    fail_rate_stds = []
    
    for outlier in outlier_values:
        subset = mech_data[mech_data['outlier_mult'] == outlier]
        fail_rates.append(subset['robust_fail_rate'].mean())
        fail_rate_stds.append(subset['robust_fail_rate'].std())
    
    ax1.plot(outlier_values, fail_rates, 'o-', label=mech, 
            linewidth=2, markersize=8, color=colors[mech])
    ax1.fill_between(outlier_values, 
                    np.array(fail_rates) - np.array(fail_rate_stds),
                    np.array(fail_rates) + np.array(fail_rate_stds),
                    alpha=0.2, color=colors[mech])

ax1.set_xlabel('å‹åŠ›æµ‹è¯•å¼ºåº¦ (Outlier Multiplier)')
ax1.set_ylabel('ç¨³å¥æ€§å¤±è´¥ç‡')
ax1.set_title('æœºåˆ¶ç¨³å¥æ€§å¯¹æ¯”\né˜´å½±åŒºåŸŸ=æ ‡å‡†å·®')
ax1.legend()
ax1.grid(True, alpha=0.3)
ax1.set_ylim(0, 1)

# å³å›¾: ç¨³å¥æ€§æ’åå˜åŒ–
robustness_ranks = {}
for outlier in outlier_values:
    subset = data[data['outlier_mult'] == outlier]
    mech_avg = subset.groupby('mechanism')['robust_fail_rate'].mean().sort_values()
    for rank, mech in enumerate(mech_avg.index):
        if mech not in robustness_ranks:
            robustness_ranks[mech] = []
        robustness_ranks[mech].append(rank + 1)

for mech, ranks in robustness_ranks.items():
    ax2.plot(outlier_values, ranks, 'o-', label=mech, 
            linewidth=2, markersize=8, color=colors[mech])

ax2.set_xlabel('å‹åŠ›æµ‹è¯•å¼ºåº¦')
ax2.set_ylabel('ç¨³å¥æ€§æ’å (1=æœ€ä½³)')
ax2.set_title('ç¨³å¥æ€§æ’åå˜åŒ–')
ax2.legend()
ax2.grid(True, alpha=0.3)
ax2.invert_yaxis()  # æ’åè¶Šå°è¶Šå¥½ï¼Œæ‰€ä»¥å€’ç½®yè½´
```

**å…³é”®è§£è¯»ç‚¹**:
- ä¸åŒæœºåˆ¶çš„ç¨³å¥æ€§å·®å¼‚
- å‹åŠ›å¢åŠ æ—¶æ€§èƒ½é€€åŒ–çš„é€Ÿåº¦
- ç¨³å¥æ€§æ’åçš„ç¨³å®šæ€§åˆ†æ

---

### å›¾4-3: å† å†›ä¸ç¡®å®šæ€§åˆ†æå›¾ (Champion Uncertainty Analysis)
**æ–‡ä»¶å**: `q4_champion_uncertainty.{tiff,eps}`

**ç›®çš„**: å±•ç¤ºä¸åŒæœºåˆ¶å¯¹ç»“æœå¯é¢„æµ‹æ€§çš„å½±å“ï¼Œå¹³è¡¡å¨±ä¹æ€§å’Œå…¬å¹³æ€§

**æ•°æ®æº**:
- å­—æ®µ: `champion_entropy, champion_mode_prob, mechanism`

**å›¾è¡¨è®¾è®¡**:
```python
fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))

# å­å›¾1: å† å†›ç†µåˆ†å¸ƒç®±çº¿å›¾
mechanism_order = ['percent', 'rank', 'percent_judge_save', 'percent_sqrt', 'percent_log', 'percent_cap', 'dynamic_weight']
entropy_data = [data[data['mechanism'] == mech]['champion_entropy'] for mech in mechanism_order]

box_plot = ax1.boxplot(entropy_data, labels=mechanism_order, patch_artist=True)
for patch, mech in zip(box_plot['boxes'], mechanism_order):
    patch.set_facecolor(colors[mech])
    patch.set_alpha(0.7)

ax1.set_ylabel('å† å†›ç†µ (Champion Entropy)')
ax1.set_title('ç»“æœä¸ç¡®å®šæ€§åˆ†å¸ƒ\nç†µè¶Šé«˜=ç»“æœè¶Šéšæœº')
ax1.tick_params(axis='x', rotation=45)
ax1.grid(True, alpha=0.3)

# å­å›¾2: å† å†›æ¨¡å¼æ¦‚ç‡åˆ†å¸ƒ
mode_prob_data = [data[data['mechanism'] == mech]['champion_mode_prob'] for mech in mechanism_order]
box_plot2 = ax2.boxplot(mode_prob_data, labels=mechanism_order, patch_artist=True)
for patch, mech in zip(box_plot2['boxes'], mechanism_order):
    patch.set_facecolor(colors[mech])
    patch.set_alpha(0.7)

ax2.set_ylabel('å† å†›æ¨¡å¼æ¦‚ç‡')
ax2.set_title('ç»“æœé›†ä¸­åº¦åˆ†å¸ƒ\næ¦‚ç‡è¶Šé«˜=ç»“æœè¶Šé›†ä¸­')
ax2.tick_params(axis='x', rotation=45)
ax2.grid(True, alpha=0.3)

# å­å›¾3: ä¸ç¡®å®šæ€§ vs æŠ€æœ¯ä¿æŠ¤æ•£ç‚¹å›¾
for mech in mechanism_order:
    mech_data = data[data['mechanism'] == mech]
    ax3.scatter(mech_data['champion_entropy'], mech_data['tpi_season_avg'],
               c=colors[mech], label=mech, alpha=0.6, s=50)

ax3.set_xlabel('å† å†›ç†µ (ç»“æœéšæœºæ€§)')
ax3.set_ylabel('æŠ€æœ¯ä¿æŠ¤æŒ‡æ•°')
ax3.set_title('éšæœºæ€§ vs æŠ€æœ¯ä¿æŠ¤æƒè¡¡')
ax3.legend()
ax3.grid(True, alpha=0.3)

# å­å›¾4: ç†æƒ³åŒºåŸŸåˆ†æ
# å®šä¹‰ç†æƒ³åŒºåŸŸï¼šé€‚ä¸­çš„ä¸ç¡®å®šæ€§ + é«˜æŠ€æœ¯ä¿æŠ¤
ideal_entropy_range = (0.5, 0.8)  # é€‚ä¸­çš„éšæœºæ€§
ideal_tpi_threshold = 0.7  # é«˜æŠ€æœ¯ä¿æŠ¤

for mech in mechanism_order:
    mech_data = data[data['mechanism'] == mech]
    ideal_count = len(mech_data[
        (mech_data['champion_entropy'] >= ideal_entropy_range[0]) &
        (mech_data['champion_entropy'] <= ideal_entropy_range[1]) &
        (mech_data['tpi_season_avg'] >= ideal_tpi_threshold)
    ])
    ideal_rate = ideal_count / len(mech_data)
    
    ax4.bar(mech, ideal_rate, color=colors[mech], alpha=0.7)

ax4.set_ylabel('ç†æƒ³åŒºåŸŸå æ¯”')
ax4.set_title('å„æœºåˆ¶åœ¨ç†æƒ³åŒºåŸŸçš„è¡¨ç°\n(é€‚ä¸­éšæœºæ€§ + é«˜æŠ€æœ¯ä¿æŠ¤)')
ax4.tick_params(axis='x', rotation=45)
ax4.grid(True, alpha=0.3)

plt.tight_layout()
```

**å…³é”®è§£è¯»ç‚¹**:
- è¿‡åº¦ç¡®å®šæ€§vsè¿‡åº¦éšæœºæ€§çš„å¹³è¡¡
- ä¸åŒæœºåˆ¶çš„å¨±ä¹æ€§å·®å¼‚
- ç†æƒ³åŒºåŸŸçš„æœºåˆ¶é€‰æ‹©

---

### å›¾4-4: å­£åº¦å·®å¼‚åˆ†æå›¾ (Seasonal Variation Analysis)
**æ–‡ä»¶å**: `q4_seasonal_variation.{tiff,eps}`

**ç›®çš„**: å±•ç¤ºæœºåˆ¶åœ¨ä¸åŒèµ›å­£ç‰¹å¾ä¸‹çš„è¡¨ç°å·®å¼‚

**æ•°æ®æº**:
- æŒ‰seasonåˆ†ç»„åˆ†ææœºåˆ¶è¡¨ç°çš„å˜å¼‚æ€§

**å›¾è¡¨è®¾è®¡**:
```python
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 12))

# ä¸Šå›¾: å„èµ›å­£TPIå˜å¼‚ç³»æ•°
seasons = sorted(data['season'].unique())
mechanisms_subset = ['percent', 'rank', 'percent_judge_save']

tpi_cv_matrix = []
for season in seasons:
    season_data = data[data['season'] == season]
    season_cvs = []
    for mech in mechanisms_subset:
        mech_data = season_data[season_data['mechanism'] == mech]
        if len(mech_data) > 0:
            cv = mech_data['tpi_season_avg'].std() / mech_data['tpi_season_avg'].mean()
            season_cvs.append(cv)
        else:
            season_cvs.append(np.nan)
    tpi_cv_matrix.append(season_cvs)

tpi_cv_matrix = np.array(tpi_cv_matrix)

# çƒ­å›¾å±•ç¤º
im1 = ax1.imshow(tpi_cv_matrix.T, cmap='YlOrRd', aspect='auto')
ax1.set_xticks(range(0, len(seasons), 5))
ax1.set_xticklabels(seasons[::5])
ax1.set_yticks(range(len(mechanisms_subset)))
ax1.set_yticklabels(mechanisms_subset)
ax1.set_xlabel('èµ›å­£')
ax1.set_title('æŠ€æœ¯ä¿æŠ¤æŒ‡æ•°å˜å¼‚ç³»æ•°çƒ­å›¾\nçº¢è‰²=é«˜å˜å¼‚æ€§')

# æ·»åŠ é¢œè‰²æ¡
cbar1 = plt.colorbar(im1, ax=ax1)
cbar1.set_label('å˜å¼‚ç³»æ•°')

# ä¸‹å›¾: æœºåˆ¶ä¸€è‡´æ€§åˆ†æ
consistency_scores = {}
for mech in mechanisms_subset:
    mech_data = data[data['mechanism'] == mech]
    # è®¡ç®—è·¨èµ›å­£çš„ä¸€è‡´æ€§ï¼ˆæ ‡å‡†å·®çš„å€’æ•°ï¼‰
    tpi_consistency = 1 / mech_data.groupby('season')['tpi_season_avg'].mean().std()
    fan_consistency = 1 / mech_data.groupby('season')['fan_vs_uniform_contrast'].mean().std()
    robust_consistency = 1 / mech_data.groupby('season')['robust_fail_rate'].mean().std()
    
    consistency_scores[mech] = [tpi_consistency, fan_consistency, robust_consistency]

# å¹¶åˆ—æŸ±çŠ¶å›¾
x = np.arange(len(mechanisms_subset))
width = 0.25
metrics = ['TPIä¸€è‡´æ€§', 'ç²‰ä¸è¡¨è¾¾ä¸€è‡´æ€§', 'ç¨³å¥æ€§ä¸€è‡´æ€§']

for i, metric in enumerate(metrics):
    values = [consistency_scores[mech][i] for mech in mechanisms_subset]
    ax2.bar(x + i*width, values, width, label=metric, alpha=0.8)

ax2.set_xlabel('æœºåˆ¶')
ax2.set_ylabel('ä¸€è‡´æ€§å¾—åˆ† (è¶Šé«˜è¶Šå¥½)')
ax2.set_title('å„æœºåˆ¶è·¨èµ›å­£ä¸€è‡´æ€§å¯¹æ¯”')
ax2.set_xticks(x + width)
ax2.set_xticklabels(mechanisms_subset)
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
```

**å…³é”®è§£è¯»ç‚¹**:
- ä¸åŒæœºåˆ¶çš„å­£åº¦ç¨³å®šæ€§å·®å¼‚
- ä¸€è‡´æ€§vsé€‚åº”æ€§çš„æƒè¡¡
- é•¿æœŸä½¿ç”¨çš„å¯é æ€§è¯„ä¼°

---

## ğŸš€ **ç‚«æŠ€å¯¹æ¯”å›¾è¡¨**

### å›¾4-5: å¤šç›®æ ‡ä¼˜åŒ–Paretoå‰æ²¿ (Multi-objective Optimization Pareto Frontier)
**æ–‡ä»¶å**: `q4_pareto_frontier.{tiff,eps}`

**ç›®çš„**: å±•ç¤ºæœºå™¨å­¦ä¹ å¤šç›®æ ‡ä¼˜åŒ–åœ¨ç³»ç»Ÿè®¾è®¡ä¸­çš„åº”ç”¨

**æ•°æ®æº**:
- `outputs/tables/showcase/mcm2026c_q4_ml_pareto_frontier.csv`
- Paretoæœ€ä¼˜è§£çš„è¯†åˆ«å’Œå¯è§†åŒ–

**å›¾è¡¨è®¾è®¡**:
```python
fig = plt.figure(figsize=(16, 12))

# 3Dæ•£ç‚¹å›¾å±•ç¤ºä¸‰ç›®æ ‡ä¼˜åŒ–
ax = fig.add_subplot(111, projection='3d')

# æ‰€æœ‰è§£
all_solutions = data[['tpi_season_avg', 'fan_vs_uniform_contrast', 'robust_fail_rate']].values
ax.scatter(all_solutions[:, 0], all_solutions[:, 1], 1-all_solutions[:, 2], 
          c='lightgray', alpha=0.3, s=20, label='æ‰€æœ‰è§£')

# Paretoæœ€ä¼˜è§£
pareto_data = pd.read_csv('outputs/tables/showcase/mcm2026c_q4_ml_pareto_frontier.csv')
if len(pareto_data) > 0:
    pareto_solutions = pareto_data[['tpi_season_avg', 'fan_vs_uniform_contrast', 'robust_fail_rate']].values
    ax.scatter(pareto_solutions[:, 0], pareto_solutions[:, 1], 1-pareto_solutions[:, 2],
              c='red', s=100, alpha=0.8, label='Paretoæœ€ä¼˜è§£')
    
    # è¿æ¥Paretoå‰æ²¿
    # å¯¹Paretoè§£æŒ‰æŸä¸ªç»´åº¦æ’åºåè¿çº¿
    sorted_indices = np.argsort(pareto_solutions[:, 0])
    sorted_pareto = pareto_solutions[sorted_indices]
    ax.plot(sorted_pareto[:, 0], sorted_pareto[:, 1], 1-sorted_pareto[:, 2],
           'r-', alpha=0.7, linewidth=2, label='Paretoå‰æ²¿')

ax.set_xlabel('æŠ€æœ¯ä¿æŠ¤æŒ‡æ•° (TPI)')
ax.set_ylabel('ç²‰ä¸è¡¨è¾¾å¼ºåº¦')
ax.set_zlabel('ç¨³å¥æ€§ (1-å¤±è´¥ç‡)')
ax.set_title('å¤šç›®æ ‡ä¼˜åŒ–Paretoå‰æ²¿\nçº¢è‰²=æœ€ä¼˜æƒè¡¡è§£')
ax.legend()

# æ·»åŠ ç†æƒ³ç‚¹æ ‡æ³¨
ideal_point = [0.8, 0.8, 0.9]  # ç†æƒ³çš„é«˜æ€§èƒ½ç‚¹
ax.scatter(*ideal_point, c='gold', s=200, marker='*', label='ç†æƒ³ç‚¹')
```

**å…³é”®è§£è¯»ç‚¹**:
- Paretoæœ€ä¼˜è§£çš„åˆ†å¸ƒç‰¹å¾
- ä¸åŒç›®æ ‡ä¹‹é—´çš„æƒè¡¡å…³ç³»
- ç†æƒ³ç‚¹ä¸å®é™…å¯è¾¾è§£çš„å·®è·

---

### å›¾4-6: æœºå™¨å­¦ä¹ ç‰¹å¾é‡è¦æ€§åˆ†æ (ML Feature Importance Analysis)
**æ–‡ä»¶å**: `q4_ml_feature_importance.{tiff,eps}`

**ç›®çš„**: å±•ç¤ºæœºå™¨å­¦ä¹ åœ¨ç³»ç»Ÿå‚æ•°ä¼˜åŒ–ä¸­è¯†åˆ«çš„å…³é”®å› ç´ 

**æ•°æ®æº**:
- `outputs/tables/showcase/mcm2026c_q4_ml_feature_importance.csv`

**å›¾è¡¨è®¾è®¡**:
```python
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))

# è¯»å–ç‰¹å¾é‡è¦æ€§æ•°æ®
feature_importance = pd.read_csv('outputs/tables/showcase/mcm2026c_q4_ml_feature_importance.csv')

# å·¦å›¾: æ•´ä½“ç‰¹å¾é‡è¦æ€§
top_features = feature_importance.head(15)
bars = ax1.barh(range(len(top_features)), top_features['importance'])
ax1.set_yticks(range(len(top_features)))
ax1.set_yticklabels(top_features['feature'])
ax1.set_xlabel('ç‰¹å¾é‡è¦æ€§')
ax1.set_title('ç³»ç»Ÿæ€§èƒ½é¢„æµ‹çš„å…³é”®ç‰¹å¾')
ax1.grid(True, alpha=0.3)

# ä¸ºä¸åŒç±»å‹çš„ç‰¹å¾ä½¿ç”¨ä¸åŒé¢œè‰²
feature_colors = []
for feature in top_features['feature']:
    if 'alpha' in feature.lower():
        feature_colors.append('lightblue')
    elif 'outlier' in feature.lower():
        feature_colors.append('lightcoral')
    elif 'season' in feature.lower():
        feature_colors.append('lightgreen')
    else:
        feature_colors.append('lightgray')

for bar, color in zip(bars, feature_colors):
    bar.set_color(color)

# å³å›¾: ç‰¹å¾ç±»åˆ«æ±‡æ€»
feature_categories = {
    'ç³»ç»Ÿå‚æ•°': ['alpha', 'outlier_mult', 'n_sims'],
    'å­£åº¦ç‰¹å¾': ['season_era', 'season'],
    'äº¤äº’æ•ˆåº”': ['alpha_outlier_interaction'],
    'è¡ç”Ÿç‰¹å¾': ['system_balance', 'robustness_score']
}

category_importance = {}
for category, features in feature_categories.items():
    total_importance = 0
    for feature in features:
        matching_rows = feature_importance[feature_importance['feature'].str.contains('|'.join(features), na=False)]
        total_importance += matching_rows['importance'].sum()
    category_importance[category] = total_importance

categories = list(category_importance.keys())
importances = list(category_importance.values())

wedges, texts, autotexts = ax2.pie(importances, labels=categories, autopct='%1.1f%%',
                                  startangle=90, colors=['lightblue', 'lightcoral', 'lightgreen', 'plum'])
ax2.set_title('ç‰¹å¾ç±»åˆ«é‡è¦æ€§åˆ†å¸ƒ')

plt.tight_layout()
```

**å…³é”®è§£è¯»ç‚¹**:
- ç³»ç»Ÿå‚æ•°vsç¯å¢ƒå› ç´ çš„ç›¸å¯¹é‡è¦æ€§
- äº¤äº’æ•ˆåº”çš„è¯†åˆ«å’Œé‡åŒ–
- ä¸ºç³»ç»Ÿè®¾è®¡æä¾›æ•°æ®é©±åŠ¨çš„æŒ‡å¯¼

---

### å›¾4-7: é¢„æµ‹æ€§èƒ½éªŒè¯å›¾ (Prediction Performance Validation)
**æ–‡ä»¶å**: `q4_prediction_validation.{tiff,eps}`

**å®šä½**: é™„å½•å¯¹ç…§ï¼ˆshowcaseï¼‰ã€‚ä¸ä½œä¸ºé¢˜é¢ä¸»çº¿å¿…é¡»äº¤ä»˜å†…å®¹ã€‚

**æ•°æ®æº**:
- `outputs/tables/showcase/mcm2026c_q4_ml_parameter_optimization.csv`
- å½“å‰ `mcm2026c_q4_ml_parameter_optimization.csv` æ˜¯â€œæ¨¡å‹çº§æ±‡æ€»â€ï¼ˆæ¯ä¸ªç›®æ ‡çš„ CV/Train æŒ‡æ ‡ï¼‰ï¼Œ
  ä¸åŒ…å«é€æ ·æœ¬é¢„æµ‹å€¼ï¼Œå› æ­¤ä¸ç»˜åˆ¶é¢„æµ‹ vs å®é™…æ•£ç‚¹å›¾ã€‚

**å›¾è¡¨è®¾è®¡**:
```python
fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))

# è¯»å–MLé¢„æµ‹ç»“æœ
ml_results = pd.read_csv('outputs/tables/showcase/mcm2026c_q4_ml_parameter_optimization.csv')

# å­å›¾1: ä¸åŒç›®æ ‡çš„é¢„æµ‹æ€§èƒ½
objectives = ['champion_mode_prob', 'robustness_score', 'tpi_season_avg']
r2_scores = []
rmse_scores = []

for obj in objectives:
    r2_col = f'{obj}_train_r2'
    rmse_col = f'{obj}_train_rmse'
    if r2_col in ml_results.columns:
        r2_scores.append(ml_results[r2_col].iloc[0])
    if rmse_col in ml_results.columns:
        rmse_scores.append(ml_results[rmse_col].iloc[0])

x = np.arange(len(objectives))
bars1 = ax1.bar(x, r2_scores, alpha=0.8, color='lightblue')
ax1.set_ylabel('RÂ² å¾—åˆ†')
ax1.set_title('å¤šç›®æ ‡é¢„æµ‹æ€§èƒ½ (RÂ²)')
ax1.set_xticks(x)
ax1.set_xticklabels(['å¯é¢„æµ‹æ€§', 'ç¨³å¥æ€§', 'æŠ€æœ¯ä¿æŠ¤'])
ax1.grid(True, alpha=0.3)

# æ·»åŠ æ•°å€¼æ ‡ç­¾
for bar, score in zip(bars1, r2_scores):
    height = bar.get_height()
    ax1.text(bar.get_x() + bar.get_width()/2., height + 0.01,
            f'{score:.3f}', ha='center', va='bottom')

# å­å›¾2: RMSEå¯¹æ¯”
bars2 = ax2.bar(x, rmse_scores, alpha=0.8, color='lightcoral')
ax2.set_ylabel('RMSE')
ax2.set_title('é¢„æµ‹è¯¯å·® (RMSE)')
ax2.set_xticks(x)
ax2.set_xticklabels(['å¯é¢„æµ‹æ€§', 'ç¨³å¥æ€§', 'æŠ€æœ¯ä¿æŠ¤'])
ax2.grid(True, alpha=0.3)

# å­å›¾3: äº¤å‰éªŒè¯æ€§èƒ½
cv_r2_scores = []
cv_std_scores = []
for obj in objectives:
    cv_r2_col = f'{obj}_cv_r2_mean'
    cv_std_col = f'{obj}_cv_r2_std'
    if cv_r2_col in ml_results.columns:
        cv_r2_scores.append(ml_results[cv_r2_col].iloc[0])
        cv_std_scores.append(ml_results[cv_std_col].iloc[0])

ax3.errorbar(x, cv_r2_scores, yerr=cv_std_scores, fmt='o', capsize=5, capthick=2, markersize=8)
ax3.set_ylabel('äº¤å‰éªŒè¯ RÂ²')
ax3.set_title('æ³›åŒ–æ€§èƒ½è¯„ä¼°')
ax3.set_xticks(x)
ax3.set_xticklabels(['å¯é¢„æµ‹æ€§', 'ç¨³å¥æ€§', 'æŠ€æœ¯ä¿æŠ¤'])
ax3.grid(True, alpha=0.3)

# å­å›¾4: è¯´æ˜
# å½“å‰ `mcm2026c_q4_ml_parameter_optimization.csv` æ˜¯â€œæ¨¡å‹çº§æ±‡æ€»â€ï¼ˆæ¯ä¸ªç›®æ ‡çš„ CV/Train æŒ‡æ ‡ï¼‰ï¼Œ
# ä¸åŒ…å«é€æ ·æœ¬é¢„æµ‹å€¼ï¼Œå› æ­¤ä¸ç»˜åˆ¶é¢„æµ‹ vs å®é™…æ•£ç‚¹å›¾ã€‚

plt.tight_layout()
```

**å…³é”®è§£è¯»ç‚¹**:
- MLæ–¹æ³•åœ¨ç³»ç»Ÿè®¾è®¡ä¸­çš„é¢„æµ‹èƒ½åŠ›
- ä¸åŒç›®æ ‡é¢„æµ‹éš¾åº¦çš„å·®å¼‚
- æ³›åŒ–æ€§èƒ½çš„éªŒè¯

---

## ğŸ“‹ **æ”¿ç­–å»ºè®®æ”¯æ’‘å›¾è¡¨**

### å›¾4-8: æœºåˆ¶æ¨èå†³ç­–æ ‘ (Mechanism Recommendation Decision Tree)
**æ–‡ä»¶å**: `q4_mechanism_recommendation.{tiff,eps}`

**ç›®çš„**: ä¸ºåˆ¶ä½œæ–¹æä¾›åŸºäºä¸åŒä¼˜å…ˆçº§çš„æœºåˆ¶é€‰æ‹©æŒ‡å¯¼

**å›¾è¡¨è®¾è®¡**:
```python
fig, ax = plt.subplots(figsize=(16, 12))

# åˆ›å»ºå†³ç­–æ ‘å¯è§†åŒ–
from matplotlib.patches import Rectangle, FancyBboxPatch
from matplotlib.patches import ConnectionPatch

# å†³ç­–èŠ‚ç‚¹
decisions = {
    'root': {'pos': (0.5, 0.9), 'text': 'åˆ¶ä½œæ–¹ä¼˜å…ˆçº§ï¼Ÿ', 'size': (0.2, 0.08)},
    'fairness': {'pos': (0.2, 0.7), 'text': 'å…¬å¹³æ€§ä¼˜å…ˆ', 'size': (0.15, 0.06)},
    'entertainment': {'pos': (0.8, 0.7), 'text': 'å¨±ä¹æ€§ä¼˜å…ˆ', 'size': (0.15, 0.06)},
    'balance': {'pos': (0.5, 0.7), 'text': 'å¹³è¡¡è€ƒè™‘', 'size': (0.15, 0.06)},
}

# å¶å­èŠ‚ç‚¹ï¼ˆæ¨èç»“æœï¼‰
recommendations = {
    'rank': {'pos': (0.1, 0.5), 'text': 'Rank\né«˜æŠ€æœ¯ä¿æŠ¤', 'color': 'lightblue'},
    'percent_judge_save': {'pos': (0.5, 0.5), 'text': 'Percent + Judge Save\nå¹³è¡¡æƒè¡¡', 'color': 'lightgreen'},
    'percent': {'pos': (0.9, 0.5), 'text': 'Percent\né«˜ç²‰ä¸è¡¨è¾¾', 'color': 'lightcoral'},
}

# ç»˜åˆ¶å†³ç­–èŠ‚ç‚¹
for node, props in decisions.items():
    bbox = FancyBboxPatch((props['pos'][0] - props['size'][0]/2, 
                          props['pos'][1] - props['size'][1]/2),
                         props['size'][0], props['size'][1],
                         boxstyle="round,pad=0.01", 
                         facecolor='lightyellow', edgecolor='black')
    ax.add_patch(bbox)
    ax.text(props['pos'][0], props['pos'][1], props['text'], 
           ha='center', va='center', fontsize=12, fontweight='bold')

# ç»˜åˆ¶æ¨èèŠ‚ç‚¹
for node, props in recommendations.items():
    bbox = FancyBboxPatch((props['pos'][0] - 0.08, props['pos'][1] - 0.04),
                         0.16, 0.08,
                         boxstyle="round,pad=0.01", 
                         facecolor=props['color'], edgecolor='black')
    ax.add_patch(bbox)
    ax.text(props['pos'][0], props['pos'][1], props['text'], 
           ha='center', va='center', fontsize=10)

# ç»˜åˆ¶è¿æ¥çº¿
connections = [
    (decisions['root']['pos'], decisions['fairness']['pos']),
    (decisions['root']['pos'], decisions['balance']['pos']),
    (decisions['root']['pos'], decisions['entertainment']['pos']),
    (decisions['fairness']['pos'], recommendations['rank']['pos']),
    (decisions['balance']['pos'], recommendations['percent_judge_save']['pos']),
    (decisions['entertainment']['pos'], recommendations['percent']['pos']),
]

for start, end in connections:
    ax.plot([start[0], end[0]], [start[1], end[1]], 'k-', alpha=0.7, linewidth=2)

# æ·»åŠ æ€§èƒ½æŒ‡æ ‡è¡¨æ ¼
performance_data = {
    'Rank': {'TPI': 0.85, 'Fan Expression': 0.65, 'Robustness': 0.80},
    'Percent + Judge Save': {'TPI': 0.75, 'Fan Expression': 0.80, 'Robustness': 0.85},
    'Percent': {'TPI': 0.65, 'Fan Expression': 0.90, 'Robustness': 0.70},
}

table_data = []
for mech, metrics in performance_data.items():
    table_data.append([mech, f"{metrics['TPI']:.2f}", 
                      f"{metrics['Fan Expression']:.2f}", 
                      f"{metrics['Robustness']:.2f}"])

table = ax.table(cellText=table_data,
                colLabels=['æœºåˆ¶', 'TPI', 'ç²‰ä¸è¡¨è¾¾', 'ç¨³å¥æ€§'],
                cellLoc='center',
                loc='lower center',
                bbox=[0.2, 0.1, 0.6, 0.25])
table.auto_set_font_size(False)
table.set_fontsize(10)
table.scale(1, 1.5)

ax.set_xlim(0, 1)
ax.set_ylim(0, 1)
ax.set_title('DWTSæŠ•ç¥¨æœºåˆ¶é€‰æ‹©å†³ç­–æŒ‡å—\nåŸºäºåˆ¶ä½œæ–¹ä¼˜å…ˆçº§çš„æ¨è', fontsize=16, fontweight='bold')
ax.axis('off')
```

**å…³é”®è§£è¯»ç‚¹**:
- åŸºäºä¸åŒä¼˜å…ˆçº§çš„æ˜ç¡®æ¨è
- æ¯ç§æ¨èçš„æ€§èƒ½æƒè¡¡
- å®ç”¨çš„å†³ç­–æ”¯æŒå·¥å…·

---

## ğŸ“‹ **æŠ€æœ¯å®ç°è§„èŒƒ**

### æ•°æ®èšåˆå’Œå¤„ç†
```python
def aggregate_mechanism_performance(data):
    """èšåˆæœºåˆ¶æ€§èƒ½æ•°æ®"""
    return data.groupby(['mechanism', 'outlier_mult']).agg({
        'tpi_season_avg': ['mean', 'std'],
        'fan_vs_uniform_contrast': ['mean', 'std'],
        'robust_fail_rate': ['mean', 'std'],
        'champion_entropy': ['mean', 'std']
    }).reset_index()

def calculate_pareto_frontier(data, objectives):
    """è®¡ç®—Paretoå‰æ²¿"""
    # å®ç°Paretoæœ€ä¼˜è§£è¯†åˆ«ç®—æ³•
    pass
```

### é¢œè‰²æ–¹æ¡ˆ
- **æœºåˆ¶ç±»å‹**:
  - `percent`: è“è‰² (#1f77b4)
  - `rank`: æ©™è‰² (#ff7f0e)
  - `percent_judge_save`: ç»¿è‰² (#2ca02c)
  - `percent_sqrt`: çº¢è‰² (#d62728)
  - `percent_log`: æ£•è‰² (#8c564b)
  - `percent_cap`: ç²‰è‰² (#e377c2)
  - `dynamic_weight`: ç°è‰² (#7f7f7f)
- **æ€§èƒ½åŒºåŸŸ**:
  - ç†æƒ³åŒºåŸŸ: é‡‘è‰²è¾¹æ¡†
  - Paretoå‰æ²¿: çº¢è‰²é«˜äº®
  - å‹åŠ›æµ‹è¯•: æ¸å˜è‰²è¡¨ç¤ºå¼ºåº¦

### 3Då¯è§†åŒ–è®¾ç½®
```python
def setup_3d_plot():
    """è®¾ç½®3Då›¾è¡¨çš„æ ‡å‡†æ ¼å¼"""
    fig = plt.figure(figsize=(12, 10))
    ax = fig.add_subplot(111, projection='3d')
    ax.view_init(elev=20, azim=45)  # æœ€ä½³è§‚å¯Ÿè§’åº¦
    return fig, ax
```

---

## ğŸ¯ **è®ºæ–‡é›†æˆç­–ç•¥**

### ä¸»çº¿è®ºè¯é€»è¾‘
1. **å›¾4-1**: æ ¸å¿ƒæƒè¡¡å…³ç³»å±•ç¤º
2. **å›¾4-2**: ç¨³å¥æ€§éªŒè¯
3. **å›¾4-3**: å¨±ä¹æ€§å¹³è¡¡åˆ†æ
4. **å›¾4-4**: é•¿æœŸç¨³å®šæ€§è¯„ä¼°

### æ”¿ç­–å»ºè®®ç­–ç•¥
1. **å›¾4-8**: å®ç”¨çš„å†³ç­–æŒ‡å¯¼å·¥å…·

### ç‚«æŠ€å±•ç¤ºç­–ç•¥
1. **å›¾4-5**: å¤šç›®æ ‡ä¼˜åŒ–å‰æ²¿æŠ€æœ¯
2. **å›¾4-6**: æœºå™¨å­¦ä¹ ç‰¹å¾åˆ†æ
3. **å›¾4-7**: é¢„æµ‹æ€§èƒ½éªŒè¯

### ä¸å…¶ä»–é¢˜ç›®çš„è¡”æ¥
- **â† Q1**: åŸºäºQ1çš„ä¸ç¡®å®šæ€§é‡åŒ–
- **â† Q2**: åäº‹å®åˆ†ææä¾›çš„åŸºå‡†å¯¹æ¯”
- **â† Q3**: å½±å“å› ç´ åˆ†ææŒ‡å¯¼æœºåˆ¶è®¾è®¡

---

## âš ï¸ **æ³¨æ„äº‹é¡¹ä¸é£é™©æ§åˆ¶**

### å¤šç›®æ ‡ä¼˜åŒ–è§£é‡Š
- æ˜ç¡®è§£é‡ŠParetoæœ€ä¼˜çš„æ¦‚å¿µ
- é¿å…æš—ç¤ºå­˜åœ¨"å®Œç¾"è§£å†³æ–¹æ¡ˆ
- å¼ºè°ƒæƒè¡¡çš„å¿…ç„¶æ€§

### æ”¿ç­–å»ºè®®çš„å±€é™æ€§
- æ˜ç¡®åŸºäºä»¿çœŸçš„å±€é™æ€§
- å¼ºè°ƒéœ€è¦å®é™…æµ‹è¯•éªŒè¯
- é¿å…è¿‡åº¦æ‰¿è¯ºæ•ˆæœ

### å¯è§†åŒ–å¤æ‚åº¦æ§åˆ¶
- 3Då›¾è¡¨æä¾›å¤šè§’åº¦è§†å›¾
- å¤æ‚çƒ­å›¾æä¾›è¯¦ç»†å›¾ä¾‹
- å†³ç­–æ ‘ä¿æŒç®€æ´æ˜äº†

è¿™ä¸ªQ4å¯è§†åŒ–è§„åˆ’ç¡®ä¿èƒ½å¤Ÿï¼š
1. **æ¸…æ™°å±•ç¤ºç³»ç»Ÿè®¾è®¡çš„å¤æ‚æ€§**ï¼šå¤šç›®æ ‡æƒè¡¡å’Œçº¦æŸæ¡ä»¶
2. **æä¾›å®ç”¨çš„æ”¿ç­–å»ºè®®**ï¼šåŸºäºæ•°æ®çš„å†³ç­–æ”¯æŒå·¥å…·
3. **å±•ç°æŠ€æœ¯åˆ›æ–°èƒ½åŠ›**ï¼šå¤šç›®æ ‡ä¼˜åŒ–å’Œæœºå™¨å­¦ä¹ åº”ç”¨
4. **ä¿æŒç§‘å­¦ä¸¥è°¨æ€§**ï¼šå®Œæ•´çš„éªŒè¯å’Œç¨³å¥æ€§åˆ†æ